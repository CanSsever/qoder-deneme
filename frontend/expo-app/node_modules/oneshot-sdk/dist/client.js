"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JobTemplates = exports.OneShotClient = void 0;
exports.createOneShotClient = createOneShotClient;
/**
 * OneShot SDK - Main client class
 */
const http_client_1 = require("./http-client");
const types_1 = require("./types");
class OneShotClient {
    constructor(config) {
        this.isAuthenticated = false;
        this.httpClient = new http_client_1.FetchHttpClient(config.baseUrl, config.timeout, config.retryAttempts, config.retryDelay);
        // Set API key if provided
        if (config.apiKey) {
            this.httpClient.setBearerToken(config.apiKey);
            this.isAuthenticated = true;
        }
    }
    /**
     * Authenticate user with email and password
     */
    async login(email, password) {
        const request = { email, password };
        const response = await this.httpClient.post('/api/v1/auth/login', request);
        // Store the token for future requests
        this.httpClient.setBearerToken(response.access_token);
        this.isAuthenticated = true;
        return response;
    }
    /**
     * Register a new user account
     */
    async register(email, password) {
        const request = { email, password };
        const response = await this.httpClient.post('/api/v1/auth/register', request);
        // Store the token for future requests (auto-login after registration)
        this.httpClient.setBearerToken(response.access_token);
        this.isAuthenticated = true;
        return response;
    }
    /**
     * Get current user profile
     */
    async getMe() {
        this.ensureAuthenticated();
        return this.httpClient.get('/api/v1/auth/me');
    }
    /**
     * Generate presigned URL for file upload
     */
    async presignUpload(filename, contentType, fileSize, idempotencyKey) {
        this.ensureAuthenticated();
        const request = {
            filename,
            content_type: contentType,
            file_size: fileSize
        };
        const options = {};
        if (idempotencyKey) {
            options.idempotencyKey = idempotencyKey;
        }
        return this.httpClient.post('/api/v1/uploads/presign', request, options);
    }
    /**
     * Upload file to presigned URL
     */
    async uploadFile(presignedUrl, file, contentType) {
        const response = await fetch(presignedUrl, {
            method: 'PUT',
            headers: {
                'Content-Type': contentType
            },
            body: file
        });
        if (!response.ok) {
            throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
        }
    }
    /**
     * Create a new AI processing job
     */
    async createJob(pipeline, inputUrl, params = {}, targetUrl, idempotencyKey) {
        this.ensureAuthenticated();
        const request = {
            job_type: pipeline,
            input_image_url: inputUrl,
            target_image_url: targetUrl,
            parameters: params
        };
        const options = {};
        if (idempotencyKey) {
            options.idempotencyKey = idempotencyKey;
        }
        return this.httpClient.post('/api/v1/jobs', request, options);
    }
    /**
     * Get job status and progress
     */
    async getJob(jobId) {
        this.ensureAuthenticated();
        return this.httpClient.get(`/api/v1/jobs/${jobId}`);
    }
    /**
     * List user's jobs with pagination
     */
    async listJobs(skip = 0, limit = 10) {
        this.ensureAuthenticated();
        return this.httpClient.get(`/api/v1/jobs?skip=${skip}&limit=${limit}`);
    }
    /**
     * Get artifacts for a specific job
     * Note: The backend doesn't have a dedicated artifacts endpoint yet,
     * so we extract artifacts from the job response
     */
    async listArtifacts(jobId) {
        this.ensureAuthenticated();
        const job = await this.getJob(jobId);
        // Convert job result to artifact format
        const artifacts = [];
        if (job.result_url) {
            artifacts.push({
                id: `${jobId}_result`,
                job_id: jobId,
                artifact_type: 'image',
                output_url: job.result_url,
                created_at: job.completed_at || job.created_at
            });
        }
        return artifacts;
    }
    /**
     * Poll job status until completion
     */
    async waitForJob(jobId, options = {}) {
        const { pollingInterval = 2000, timeout = 300000, onProgress } = options;
        const startTime = Date.now();
        while (Date.now() - startTime < timeout) {
            const job = await this.getJob(jobId);
            if (onProgress) {
                onProgress(job);
            }
            if (job.status === 'succeeded' || job.status === 'failed' || job.status === 'cancelled') {
                return job;
            }
            await this.delay(pollingInterval);
        }
        throw new Error(`Job ${jobId} timed out after ${timeout}ms`);
    }
    /**
     * Get user's plan limits and usage
     */
    async getUserLimits() {
        this.ensureAuthenticated();
        return this.httpClient.get('/api/v1/jobs/limits');
    }
    /**
     * Logout - clear authentication token
     */
    logout() {
        this.httpClient.clearBearerToken();
        this.isAuthenticated = false;
    }
    /**
     * Check if client is authenticated
     */
    isAuth() {
        return this.isAuthenticated;
    }
    /**
     * Set authentication token manually
     */
    setAuthToken(token) {
        this.httpClient.setBearerToken(token);
        this.isAuthenticated = true;
    }
    ensureAuthenticated() {
        if (!this.isAuthenticated) {
            throw new Error('Client is not authenticated. Call login() first.');
        }
    }
    async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
exports.OneShotClient = OneShotClient;
// Factory function for convenient SDK initialization
function createOneShotClient(config) {
    return new OneShotClient(config);
}
// Convenience functions for common job types
exports.JobTemplates = {
    faceRestore: (inputUrl, params = {}) => ({
        pipeline: types_1.JobType.FACE_RESTORATION,
        inputUrl,
        params: {
            face_restore: params.model || 'gfpgan',
            enhance: params.enhance ?? true,
            ...params
        }
    }),
    faceSwap: (inputUrl, targetUrl, params = {}) => ({
        pipeline: types_1.JobType.FACE_SWAP,
        inputUrl,
        targetUrl,
        params: {
            blend: params.blend ?? 0.8,
            lora: params.lora,
            ...params
        }
    }),
    upscale: (inputUrl, params = {}) => ({
        pipeline: types_1.JobType.UPSCALE,
        inputUrl,
        params: {
            scale_factor: params.scale ?? 2,
            model: params.model || 'realesrgan_x4plus',
            ...params
        }
    })
};
//# sourceMappingURL=client.js.map