"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchHttpClient = void 0;
/**
 * HTTP Client with retry logic and error handling
 */
const types_1 = require("./types");
class FetchHttpClient {
    constructor(baseUrl, timeout = 30000, retryAttempts = 3, retryDelay = 1000) {
        this.baseUrl = baseUrl.replace(/\/$/, ''); // Remove trailing slash
        this.defaultTimeout = timeout;
        this.defaultRetryAttempts = retryAttempts;
        this.defaultRetryDelay = retryDelay;
    }
    setBearerToken(token) {
        this.bearerToken = token;
    }
    clearBearerToken() {
        this.bearerToken = undefined;
    }
    async get(url, options) {
        return this.request('GET', url, undefined, options);
    }
    async post(url, data, options) {
        return this.request('POST', url, data, options);
    }
    async put(url, data, options) {
        return this.request('PUT', url, data, options);
    }
    async delete(url, options) {
        return this.request('DELETE', url, undefined, options);
    }
    async request(method, url, data, options) {
        const fullUrl = url.startsWith('http') ? url : `${this.baseUrl}${url}`;
        const timeout = options?.timeout ?? this.defaultTimeout;
        const retryAttempts = options?.retryAttempts ?? this.defaultRetryAttempts;
        const headers = {
            'Content-Type': 'application/json',
            ...options?.headers
        };
        // Add Authorization header if token is available
        if (this.bearerToken) {
            headers.Authorization = `Bearer ${this.bearerToken}`;
        }
        // Add idempotency key if provided
        if (options?.idempotencyKey) {
            headers['Idempotency-Key'] = options.idempotencyKey;
        }
        // Create AbortController for timeout (manual implementation for React Native compatibility)
        let controller = null;
        let timeoutId = null;
        const requestConfig = {
            method,
            headers
        };
        // Always use manual timeout implementation for React Native compatibility
        controller = new AbortController();
        requestConfig.signal = controller.signal;
        timeoutId = setTimeout(() => {
            if (controller) {
                controller.abort();
            }
        }, timeout);
        if (data && (method === 'POST' || method === 'PUT')) {
            requestConfig.body = JSON.stringify(data);
        }
        try {
            const result = await this.executeWithRetry(fullUrl, requestConfig, retryAttempts);
            // Clear timeout if request succeeds
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            return result;
        }
        catch (error) {
            // Clear timeout if request fails
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            throw error;
        }
    }
    async executeWithRetry(url, config, retriesLeft) {
        try {
            const response = await fetch(url, config);
            return await this.handleResponse(response);
        }
        catch (error) {
            // Check if this is a timeout error
            if (config.signal && config.signal.aborted) {
                error = new Error('Request timeout');
                error.name = 'AbortError';
            }
            if (this.shouldRetry(error, retriesLeft)) {
                await this.delay(this.defaultRetryDelay);
                return this.executeWithRetry(url, config, retriesLeft - 1);
            }
            throw this.normalizeError(error);
        }
    }
    async handleResponse(response) {
        let data;
        try {
            const text = await response.text();
            data = text ? JSON.parse(text) : {};
        }
        catch {
            data = {};
        }
        if (!response.ok) {
            throw this.createErrorFromResponse(response, data);
        }
        return data;
    }
    createErrorFromResponse(response, data) {
        const message = data?.error?.message || data?.detail || data?.message || 'Request failed';
        const code = data?.error?.code || data?.error_code || 'UNKNOWN_ERROR';
        switch (response.status) {
            case 401:
                return new types_1.AuthenticationError(message);
            case 402:
                return new types_1.PaymentRequiredError(message);
            case 422:
                return new types_1.ValidationError(message, data?.error?.details || data?.details);
            case 429:
                return new types_1.RateLimitError(message);
            default:
                return new types_1.OneShotError(code, message, response.status, data);
        }
    }
    shouldRetry(error, retriesLeft) {
        if (retriesLeft <= 0)
            return false;
        // Retry on network errors, timeouts, and 5xx server errors
        if (error instanceof types_1.NetworkError)
            return true;
        if (error.name === 'AbortError')
            return true; // Timeout
        if (error instanceof types_1.OneShotError && error.statusCode && error.statusCode >= 500) {
            return true;
        }
        return false;
    }
    normalizeError(error) {
        if (error instanceof types_1.OneShotError) {
            return error;
        }
        // Check for timeout errors
        if (error.name === 'AbortError' ||
            (error.message && (error.message.includes('timeout') || error.message.includes('aborted')))) {
            return new types_1.NetworkError('Request timeout');
        }
        if (error instanceof TypeError && error.message.includes('fetch')) {
            return new types_1.NetworkError('Network connection failed');
        }
        return new types_1.OneShotError(types_1.ErrorCode.NETWORK_ERROR, error.message || 'Unknown error');
    }
    async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
exports.FetchHttpClient = FetchHttpClient;
//# sourceMappingURL=http-client.js.map